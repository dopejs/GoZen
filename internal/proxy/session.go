package proxy

import (
	"fmt"
	"sync"
	"time"
)

// TurnUsage represents token usage for a single conversation turn.
type TurnUsage struct {
	InputTokens  int       `json:"input_tokens"`
	OutputTokens int       `json:"output_tokens"`
	Cost         float64   `json:"cost"`
	Model        string    `json:"model,omitempty"`
	Provider     string    `json:"provider,omitempty"`
	LatencyMs    int       `json:"latency_ms,omitempty"`
	Timestamp    time.Time `json:"timestamp"`
}

// SessionUsage stores token usage information for a session.
//
// IMPORTANT: InputTokens represents the ACTUAL tokens sent to the API,
// which may include:
// - Current request tokens
// - Historical context tokens
// - Tokens AFTER Claude Code's automatic context compaction
//
// This means InputTokens reflects the real token count that was billed,
// not the original uncompacted context size.
type SessionUsage struct {
	InputTokens  int         `json:"input_tokens"`  // Actual input tokens sent to API (after compaction)
	OutputTokens int         `json:"output_tokens"` // Output tokens generated by API
	TotalCost    float64     `json:"total_cost"`    // Total cost in USD
	TurnCount    int         `json:"turn_count"`    // Number of conversation turns
	Turns        []TurnUsage `json:"turns,omitempty"` // Per-turn details (limited history)
	Timestamp    time.Time   `json:"timestamp"`     // When this usage was last updated
}

// SessionInsight provides detailed insights about a session.
type SessionInsight struct {
	SessionID       string       `json:"session_id"`
	TotalInput      int          `json:"total_input"`
	TotalOutput     int          `json:"total_output"`
	TotalCost       float64      `json:"total_cost"`
	TurnCount       int          `json:"turn_count"`
	AvgInputPerTurn float64      `json:"avg_input_per_turn"`
	AvgOutputPerTurn float64     `json:"avg_output_per_turn"`
	AvgCostPerTurn  float64      `json:"avg_cost_per_turn"`
	RecentTurns     []TurnUsage  `json:"recent_turns,omitempty"`
	StartTime       *time.Time   `json:"start_time,omitempty"`
	LastActivity    *time.Time   `json:"last_activity,omitempty"`
	Duration        string       `json:"duration,omitempty"`
}

// ContextWarning provides a warning when context is getting large.
type ContextWarning struct {
	SessionID       string  `json:"session_id"`
	CurrentTokens   int     `json:"current_tokens"`
	Threshold       int     `json:"threshold"`
	PercentUsed     float64 `json:"percent_used"`
	Warning         string  `json:"warning"`
	Recommendation  string  `json:"recommendation"`
}

// SessionCache manages session usage data with LRU eviction.
type SessionCache struct {
	data     sync.Map // sessionID -> *SessionUsage
	mu       sync.Mutex
	maxSize  int
	keyOrder []string // Track insertion order for LRU
}

const defaultMaxCacheSize = 1000 // Maximum number of sessions to cache

var globalSessionCache = &SessionCache{
	maxSize: defaultMaxCacheSize,
}

// GetSessionUsage retrieves the last usage for a session.
func GetSessionUsage(sessionID string) *SessionUsage {
	if sessionID == "" {
		return nil
	}
	globalSessionCache.mu.Lock()
	defer globalSessionCache.mu.Unlock()

	if val, ok := globalSessionCache.data.Load(sessionID); ok {
		usage := val.(*SessionUsage)
		usage.Timestamp = time.Now()
		return usage
	}
	return nil
}

// UpdateSessionUsage stores or updates usage information for a session.
// Implements LRU eviction when cache is full.
func UpdateSessionUsage(sessionID string, usage *SessionUsage) {
	if sessionID == "" || usage == nil {
		return
	}
	usage.Timestamp = time.Now()

	globalSessionCache.mu.Lock()
	defer globalSessionCache.mu.Unlock()

	// Check if session already exists
	if _, exists := globalSessionCache.data.Load(sessionID); !exists {
		// New session - check if we need to evict
		if len(globalSessionCache.keyOrder) >= globalSessionCache.maxSize {
			// Evict oldest session
			if len(globalSessionCache.keyOrder) > 0 {
				oldestKey := globalSessionCache.keyOrder[0]
				globalSessionCache.data.Delete(oldestKey)
				globalSessionCache.keyOrder = globalSessionCache.keyOrder[1:]
			}
		}
		// Add to key order
		globalSessionCache.keyOrder = append(globalSessionCache.keyOrder, sessionID)
	}

	globalSessionCache.data.Store(sessionID, usage)
}

// ClearSessionUsage removes usage data for a specific session.
// This should be called when the user clears their context.
func ClearSessionUsage(sessionID string) {
	if sessionID == "" {
		return
	}

	globalSessionCache.mu.Lock()
	defer globalSessionCache.mu.Unlock()

	globalSessionCache.data.Delete(sessionID)

	// Remove from key order
	for i, key := range globalSessionCache.keyOrder {
		if key == sessionID {
			globalSessionCache.keyOrder = append(globalSessionCache.keyOrder[:i], globalSessionCache.keyOrder[i+1:]...)
			break
		}
	}
}

// CleanupOldSessions removes sessions older than the specified duration.
// This should be called periodically to prevent memory leaks.
func CleanupOldSessions(maxAge time.Duration) int {
	globalSessionCache.mu.Lock()
	defer globalSessionCache.mu.Unlock()

	now := time.Now()
	var toDelete []string
	var newKeyOrder []string

	// Find sessions to delete
	for _, sessionID := range globalSessionCache.keyOrder {
		if val, ok := globalSessionCache.data.Load(sessionID); ok {
			usage := val.(*SessionUsage)
			if now.Sub(usage.Timestamp) > maxAge {
				toDelete = append(toDelete, sessionID)
			} else {
				newKeyOrder = append(newKeyOrder, sessionID)
			}
		}
	}

	// Delete old sessions
	for _, sessionID := range toDelete {
		globalSessionCache.data.Delete(sessionID)
	}

	globalSessionCache.keyOrder = newKeyOrder
	return len(toDelete)
}

// GetCacheStats returns statistics about the session cache.
func GetCacheStats() (size int, maxSize int) {
	globalSessionCache.mu.Lock()
	defer globalSessionCache.mu.Unlock()
	return len(globalSessionCache.keyOrder), globalSessionCache.maxSize
}

// extractSessionID extracts the session ID from request metadata.
// Claude Code sends session ID in metadata.user_id as "user_session_<id>".
func extractSessionID(body map[string]interface{}) string {
	metadata, ok := body["metadata"].(map[string]interface{})
	if !ok {
		return ""
	}

	userID, ok := metadata["user_id"].(string)
	if !ok {
		return ""
	}

	// Parse "user_session_<id>" format
	const prefix = "user_session_"
	if len(userID) > len(prefix) && userID[:len(prefix)] == prefix {
		return userID[len(prefix):]
	}

	return ""
}

// AddTurnToSession adds a turn to the session's history.
func AddTurnToSession(sessionID string, turn TurnUsage) {
	if sessionID == "" {
		return
	}

	globalSessionCache.mu.Lock()
	defer globalSessionCache.mu.Unlock()

	val, ok := globalSessionCache.data.Load(sessionID)
	if !ok {
		// Create new session
		usage := &SessionUsage{
			InputTokens:  turn.InputTokens,
			OutputTokens: turn.OutputTokens,
			TotalCost:    turn.Cost,
			TurnCount:    1,
			Turns:        []TurnUsage{turn},
			Timestamp:    time.Now(),
		}
		globalSessionCache.keyOrder = append(globalSessionCache.keyOrder, sessionID)
		globalSessionCache.data.Store(sessionID, usage)
		return
	}

	usage := val.(*SessionUsage)
	usage.InputTokens = turn.InputTokens // Latest input tokens (cumulative context)
	usage.OutputTokens += turn.OutputTokens
	usage.TotalCost += turn.Cost
	usage.TurnCount++
	usage.Timestamp = time.Now()

	// Keep only last 20 turns to limit memory
	const maxTurns = 20
	usage.Turns = append(usage.Turns, turn)
	if len(usage.Turns) > maxTurns {
		usage.Turns = usage.Turns[len(usage.Turns)-maxTurns:]
	}

	globalSessionCache.data.Store(sessionID, usage)
}

// GetSessionInsight returns detailed insights for a session.
func GetSessionInsight(sessionID string) *SessionInsight {
	if sessionID == "" {
		return nil
	}

	globalSessionCache.mu.Lock()
	val, ok := globalSessionCache.data.Load(sessionID)
	if !ok {
		globalSessionCache.mu.Unlock()
		return nil
	}

	usage := val.(*SessionUsage)
	// Copy data under lock to avoid race
	insight := &SessionInsight{
		SessionID:   sessionID,
		TotalInput:  usage.InputTokens,
		TotalOutput: usage.OutputTokens,
		TotalCost:   usage.TotalCost,
		TurnCount:   usage.TurnCount,
	}
	turnsCopy := make([]TurnUsage, len(usage.Turns))
	copy(turnsCopy, usage.Turns)
	globalSessionCache.mu.Unlock()

	if insight.TurnCount > 0 {
		// Calculate cumulative input across all turns for average
		var totalInputAcrossTurns int
		for _, t := range turnsCopy {
			totalInputAcrossTurns += t.InputTokens
		}
		if len(turnsCopy) > 0 {
			insight.AvgInputPerTurn = float64(totalInputAcrossTurns) / float64(len(turnsCopy))
		}
		insight.AvgOutputPerTurn = float64(insight.TotalOutput) / float64(insight.TurnCount)
		insight.AvgCostPerTurn = insight.TotalCost / float64(insight.TurnCount)
	}

	// Get recent turns (last 10)
	if len(turnsCopy) > 0 {
		start := 0
		if len(turnsCopy) > 10 {
			start = len(turnsCopy) - 10
		}
		insight.RecentTurns = turnsCopy[start:]

		// Calculate duration
		firstTurn := turnsCopy[0].Timestamp
		lastTurn := turnsCopy[len(turnsCopy)-1].Timestamp
		insight.StartTime = &firstTurn
		insight.LastActivity = &lastTurn
		insight.Duration = formatDuration(lastTurn.Sub(firstTurn))
	}

	return insight
}

// GetContextWarning checks if context size is approaching limits.
func GetContextWarning(sessionID string, threshold int) *ContextWarning {
	if sessionID == "" {
		return nil
	}

	if threshold <= 0 {
		threshold = 100000 // Default 100k tokens
	}

	globalSessionCache.mu.Lock()
	val, ok := globalSessionCache.data.Load(sessionID)
	if !ok {
		globalSessionCache.mu.Unlock()
		return nil
	}

	usage := val.(*SessionUsage)
	currentTokens := usage.InputTokens
	globalSessionCache.mu.Unlock()

	if currentTokens < int(float64(threshold)*0.7) {
		return nil // No warning needed
	}

	percentUsed := float64(currentTokens) / float64(threshold) * 100

	warning := &ContextWarning{
		SessionID:     sessionID,
		CurrentTokens: currentTokens,
		Threshold:     threshold,
		PercentUsed:   percentUsed,
	}

	if percentUsed >= 90 {
		warning.Warning = "Context is nearly full"
		warning.Recommendation = "Consider starting a new session or using /compact to reduce context"
	} else if percentUsed >= 80 {
		warning.Warning = "Context is getting large"
		warning.Recommendation = "Context may be automatically compacted soon"
	} else {
		warning.Warning = "Context usage is elevated"
		warning.Recommendation = "Monitor context size for optimal performance"
	}

	return warning
}

// GetAllSessionInsights returns insights for all active sessions.
func GetAllSessionInsights() []*SessionInsight {
	globalSessionCache.mu.Lock()
	sessionIDs := make([]string, len(globalSessionCache.keyOrder))
	copy(sessionIDs, globalSessionCache.keyOrder)
	globalSessionCache.mu.Unlock()

	var insights []*SessionInsight
	for _, id := range sessionIDs {
		if insight := GetSessionInsight(id); insight != nil {
			insights = append(insights, insight)
		}
	}

	return insights
}

func formatDuration(d time.Duration) string {
	if d < time.Minute {
		return "< 1 minute"
	}
	if d < time.Hour {
		mins := int(d.Minutes())
		if mins == 1 {
			return "1 minute"
		}
		return fmt.Sprintf("%02d minutes", mins)
	}
	hours := int(d.Hours())
	mins := int(d.Minutes()) % 60
	if hours == 1 {
		return fmt.Sprintf("1 hour %02d minutes", mins)
	}
	return fmt.Sprintf("%02d hours", hours)
}
