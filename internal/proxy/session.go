package proxy

import (
	"sync"
	"time"
)

// SessionUsage stores token usage information for a session.
//
// IMPORTANT: InputTokens represents the ACTUAL tokens sent to the API,
// which may include:
// - Current request tokens
// - Historical context tokens
// - Tokens AFTER Claude Code's automatic context compaction
//
// This means InputTokens reflects the real token count that was billed,
// not the original uncompacted context size.
type SessionUsage struct {
	InputTokens  int       // Actual input tokens sent to API (after compaction)
	OutputTokens int       // Output tokens generated by API
	Timestamp    time.Time // When this usage was recorded
}

// SessionCache manages session usage data with LRU eviction.
type SessionCache struct {
	data     sync.Map // sessionID -> *SessionUsage
	mu       sync.Mutex
	maxSize  int
	keyOrder []string // Track insertion order for LRU
}

const defaultMaxCacheSize = 1000 // Maximum number of sessions to cache

var globalSessionCache = &SessionCache{
	maxSize: defaultMaxCacheSize,
}

// GetSessionUsage retrieves the last usage for a session.
func GetSessionUsage(sessionID string) *SessionUsage {
	if sessionID == "" {
		return nil
	}
	if val, ok := globalSessionCache.data.Load(sessionID); ok {
		usage := val.(*SessionUsage)
		// Update timestamp to mark as recently used
		usage.Timestamp = time.Now()
		return usage
	}
	return nil
}

// UpdateSessionUsage stores or updates usage information for a session.
// Implements LRU eviction when cache is full.
func UpdateSessionUsage(sessionID string, usage *SessionUsage) {
	if sessionID == "" || usage == nil {
		return
	}
	usage.Timestamp = time.Now()

	globalSessionCache.mu.Lock()
	defer globalSessionCache.mu.Unlock()

	// Check if session already exists
	if _, exists := globalSessionCache.data.Load(sessionID); !exists {
		// New session - check if we need to evict
		if len(globalSessionCache.keyOrder) >= globalSessionCache.maxSize {
			// Evict oldest session
			if len(globalSessionCache.keyOrder) > 0 {
				oldestKey := globalSessionCache.keyOrder[0]
				globalSessionCache.data.Delete(oldestKey)
				globalSessionCache.keyOrder = globalSessionCache.keyOrder[1:]
			}
		}
		// Add to key order
		globalSessionCache.keyOrder = append(globalSessionCache.keyOrder, sessionID)
	}

	globalSessionCache.data.Store(sessionID, usage)
}

// ClearSessionUsage removes usage data for a specific session.
// This should be called when the user clears their context.
func ClearSessionUsage(sessionID string) {
	if sessionID == "" {
		return
	}

	globalSessionCache.mu.Lock()
	defer globalSessionCache.mu.Unlock()

	globalSessionCache.data.Delete(sessionID)

	// Remove from key order
	for i, key := range globalSessionCache.keyOrder {
		if key == sessionID {
			globalSessionCache.keyOrder = append(globalSessionCache.keyOrder[:i], globalSessionCache.keyOrder[i+1:]...)
			break
		}
	}
}

// CleanupOldSessions removes sessions older than the specified duration.
// This should be called periodically to prevent memory leaks.
func CleanupOldSessions(maxAge time.Duration) int {
	globalSessionCache.mu.Lock()
	defer globalSessionCache.mu.Unlock()

	now := time.Now()
	var toDelete []string
	var newKeyOrder []string

	// Find sessions to delete
	for _, sessionID := range globalSessionCache.keyOrder {
		if val, ok := globalSessionCache.data.Load(sessionID); ok {
			usage := val.(*SessionUsage)
			if now.Sub(usage.Timestamp) > maxAge {
				toDelete = append(toDelete, sessionID)
			} else {
				newKeyOrder = append(newKeyOrder, sessionID)
			}
		}
	}

	// Delete old sessions
	for _, sessionID := range toDelete {
		globalSessionCache.data.Delete(sessionID)
	}

	globalSessionCache.keyOrder = newKeyOrder
	return len(toDelete)
}

// GetCacheStats returns statistics about the session cache.
func GetCacheStats() (size int, maxSize int) {
	globalSessionCache.mu.Lock()
	defer globalSessionCache.mu.Unlock()
	return len(globalSessionCache.keyOrder), globalSessionCache.maxSize
}

// extractSessionID extracts the session ID from request metadata.
// Claude Code sends session ID in metadata.user_id as "user_session_<id>".
func extractSessionID(body map[string]interface{}) string {
	metadata, ok := body["metadata"].(map[string]interface{})
	if !ok {
		return ""
	}

	userID, ok := metadata["user_id"].(string)
	if !ok {
		return ""
	}

	// Parse "user_session_<id>" format
	const prefix = "user_session_"
	if len(userID) > len(prefix) && userID[:len(prefix)] == prefix {
		return userID[len(prefix):]
	}

	return ""
}
